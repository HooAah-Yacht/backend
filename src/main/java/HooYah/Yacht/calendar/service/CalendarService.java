package HooYah.Yacht.calendar.service;

import HooYah.Yacht.calendar.domain.Calendar;
import HooYah.Yacht.calendar.domain.CalendarType;
import HooYah.Yacht.calendar.dto.request.CalendarCreateRequest;
import HooYah.Yacht.calendar.dto.request.CalendarUpdateRequest;
import HooYah.Yacht.calendar.dto.response.CalendarInfo;
import HooYah.Yacht.calendar.repository.CalendarRepository;
import HooYah.Yacht.common.excetion.CustomException;
import HooYah.Yacht.common.excetion.ErrorCode;
import HooYah.Yacht.part.domain.Part;
import HooYah.Yacht.part.repository.PartRepository;
import HooYah.Yacht.repair.domain.Repair;
import HooYah.Yacht.repair.repository.RepairPort;
import HooYah.Yacht.repair.repository.RepairRepository;
import HooYah.Yacht.user.domain.User;
import HooYah.Yacht.yacht.domain.Yacht;
import HooYah.Yacht.yacht.repository.YachtRepository;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class CalendarService {

    private final CalendarRepository calendarRepository;
    private final PartRepository partRepository;
    private final YachtRepository yachtRepository;
    private final RepairPort repairPort;
    private final RepairRepository repairRepository;

    @Transactional
    public CalendarInfo createCalendar(CalendarCreateRequest request, User user) {
        validateDateRange(request.getStartDate(), request.getEndDate());

        Part part = findPartOrNull(request.getPartId());
        Yacht yacht = findYachtOrNull(request.getYachtId());
        
        boolean completed = Boolean.TRUE.equals(request.getCompleted());
        boolean byUser = request.getByUser() != null 
                ? Boolean.TRUE.equals(request.getByUser())
                : (request.getType() == CalendarType.SAILING || request.getType() == CalendarType.INSPECTION);
        
        // 같은 부품에 하나의 캘린더만 존재하도록 처리
        if (request.getType() == CalendarType.PART && part != null) {
            List<Calendar> existingPartCalendars = calendarRepository
                    .findByPartAndType(part, CalendarType.PART);
            
            if (!existingPartCalendars.isEmpty()) {
                // 기존 자동 생성 캘린더 찾기
                Optional<Calendar> autoGeneratedCalendar = existingPartCalendars.stream()
                        .filter(c -> !c.isByUser())
                        .findFirst();
                
                if (autoGeneratedCalendar.isPresent()) {
                    Calendar existingAutoCalendar = autoGeneratedCalendar.get();
                    // 사용자가 입력한 날짜가 이전 or 이후 -> 기존 자동 생성 캘린더를 업데이트
                    existingAutoCalendar.updateDates(request.getStartDate(), request.getEndDate());
                    if (request.getContent() != null) {
                        existingAutoCalendar.updateContent(request.getContent());
                    }
                    existingAutoCalendar.markAsUserModified();
                    
                    // 완료 상태로 생성하는 경우 정비 이력 추가
                    if (completed && user != null) {
                        handleCompletedCalendar(existingAutoCalendar, null, part, user);
                    }
                    
                    return CalendarInfo.from(existingAutoCalendar);
                } else {
                    // 자동 생성 캘린더는 없지만 사용자가 생성한 캘린더가 있으면 기존 일정 삭제
                    existingPartCalendars.forEach(calendarRepository::delete);
                }
            }
        }
        
        Calendar calendar = Calendar.builder()
                .type(request.getType())
                .part(part)
                .yacht(yacht)
                .startDate(request.getStartDate())
                .endDate(request.getEndDate())
                .completed(completed)
                .byUser(byUser)
                .content(request.getContent())
                .build();

        Calendar saved = calendarRepository.save(calendar);
        
        // 완료 상태로 생성하는 경우 정비 이력 추가
        if (completed && user != null) {
            handleCompletedCalendar(saved, request.getPartId(), part, user);
        }
        
        return CalendarInfo.from(saved);
    }

    public CalendarInfo getCalendar(Long id) {
        Calendar calendar = getCalendarOrThrow(id);
        return CalendarInfo.from(calendar);
    }

    public List<CalendarInfo> getCalendars(Long partId) {
        List<Calendar> calendars = partId != null
                ? calendarRepository.findAllByPartId(partId)
                : calendarRepository.findAll();

        return calendars.stream()
                .map(CalendarInfo::from)
                .collect(Collectors.toList());
    }

    @Transactional
    public CalendarInfo updateCalendar(Long id, CalendarUpdateRequest request, User user) {
        validateDateRange(request.getStartDate(), request.getEndDate());

        Calendar calendar = getCalendarOrThrow(id);
        Part part = findPartOrNull(request.getPartId());
        Yacht yacht = findYachtOrNull(request.getYachtId());
        
        boolean isDateChanged = !calendar.getStartDate().equals(request.getStartDate()) 
                || !calendar.getEndDate().equals(request.getEndDate());

        // 사용자가 수정했는지
        boolean shouldMarkAsUserModified = calendar.getType() == CalendarType.PART 
                && isDateChanged 
                && !calendar.isByUser();
        
        if (shouldMarkAsUserModified) {
            calendar.markAsUserModified();
        }
        
        // 완료 상태가 false에서 true로 변경될 때 처리
        boolean wasCompleted = calendar.isCompleted();
        boolean willBeCompleted = Boolean.TRUE.equals(request.getCompleted());
        boolean isCompleting = !wasCompleted && willBeCompleted;
        
        calendar.update(
                request.getType(),
                part,
                yacht,
                request.getStartDate(),
                request.getEndDate(),
                request.getCompleted(),
                request.getByUser(),
                request.getContent()
        );

        if (isCompleting && user != null) {
            handleCompletedCalendar(calendar, request.getPartId(), part, user);
        }

        return CalendarInfo.from(calendar);
    }

    @Transactional
    public void deleteCalendar(Long id) {
        Calendar calendar = getCalendarOrThrow(id);
        calendarRepository.delete(calendar);
    }

    private Calendar getCalendarOrThrow(Long id) {
        return calendarRepository.findById(id)
                .orElseThrow(() -> new CustomException(ErrorCode.NOT_FOUND));
    }

    private Part findPartOrNull(Long partId) {
        if (partId == null) {
            return null;
        }

        return partRepository.findById(partId)
                .orElseThrow(() -> new CustomException(ErrorCode.NOT_FOUND));
    }

    private Yacht findYachtOrNull(Long yachtId) {
        if (yachtId == null) {
            return null;
        }

        return yachtRepository.findById(yachtId)
                .orElseThrow(() -> new CustomException(ErrorCode.NOT_FOUND));
    }

    @Transactional
    public void autoCreatePartTypeCalendar(Part part) {
        // 정비 주기가 없으면 캘린더 자동 생성 X
        if (part.getInterval() == null) {
            return;
        }

        // 최근 정비일 조회 -> 최근 정비일 기준으로 다음 정비일 계산
        Optional<Repair> lastRepairOpt = repairPort.findLastRepair(part);
        if (lastRepairOpt.isEmpty()) {
            return; // 정비 이력이 없으면 캘린더 자동 생성 X
        }

        Repair lastRepair = lastRepairOpt.get();
        OffsetDateTime nextRepairDate = part.nextRepairDate(lastRepair.getRepairDate());
        OffsetDateTime now = OffsetDateTime.now();

        // next repair date가 오늘 이전이라면 오늘로 설정
        if (nextRepairDate.isBefore(now)) {
            nextRepairDate = now;
        }

        // 기존 자동 생성된 부품 캘린더 조회 (사용자가 수정하지 않은 것만) -> 자동 생성된 캘린더는 byUser가 false
        Optional<Calendar> existingCalendarOpt = calendarRepository
                .findByPartAndTypeAndByUserFalse(part, CalendarType.PART);

        if (existingCalendarOpt.isPresent()) {
            // 기존 캘린더가 있고 && next repair date가 오늘 이후라면 업데이트
            Calendar existingCalendar = existingCalendarOpt.get();
            if (nextRepairDate.isAfter(now) || nextRepairDate.isEqual(now)) {
                existingCalendar.updateDates(nextRepairDate, nextRepairDate);
            }
        } else {
            // 기존 캘린더가 없으면 새로 생성
            Calendar newCalendar = Calendar.builder()
                    .type(CalendarType.PART)
                    .part(part)
                    .yacht(part.getYacht())
                    .startDate(nextRepairDate)
                    .endDate(nextRepairDate)
                    .completed(false)
                    .byUser(false)
                    .content(null)
                    .build();
            calendarRepository.save(newCalendar);
        }
    }


    private void validateDateRange(OffsetDateTime startDate, OffsetDateTime endDate) {
        if (startDate != null && endDate != null && endDate.isBefore(startDate)) {
            throw new CustomException(ErrorCode.BAD_REQUEST);
        }
    }

    private void handleCompletedCalendar(Calendar calendar, Long requestPartId, Part part, User user) {
        CalendarType calendarType = calendar.getType();
        Part calendarPart = calendar.getPart();
        
        if (calendarType == CalendarType.PART && calendarPart != null) {
            // 부품 타입: 정비 이력 추가 및 다음 일정 자동 생성
            addRepairAndCreateNextCalendar(calendarPart, user);
        } else if ((calendarType == CalendarType.SAILING || calendarType == CalendarType.INSPECTION)
                && requestPartId != null && part != null
                && part.getYacht().equals(calendar.getYacht())) {
            // 세일링/점검 타입: 부품 id가 요트에 등록된 부품 id라면 정비 이력 추가
            addRepair(part, user);
        }
    }

    private void addRepairAndCreateNextCalendar(Part part, User user) {
        addRepair(part, user);
        autoCreatePartTypeCalendar(part);
    }

    private void addRepair(Part part, User user) {
        OffsetDateTime repairDate = OffsetDateTime.now();
        Repair repair = Repair.builder()
                .part(part)
                .user(user)
                .repairDate(repairDate)
                .build();
        repairRepository.save(repair);
    }
}

