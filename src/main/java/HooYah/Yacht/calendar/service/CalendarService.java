package HooYah.Yacht.calendar.service;

import HooYah.Yacht.calendar.domain.Calendar;
import HooYah.Yacht.calendar.domain.CalendarType;
import HooYah.Yacht.calendar.dto.request.CalendarCreateRequest;
import HooYah.Yacht.calendar.dto.request.CalendarUpdateRequest;
import HooYah.Yacht.calendar.dto.response.CalendarInfo;
import HooYah.Yacht.calendar.repository.CalendarRepository;
import HooYah.Yacht.common.excetion.CustomException;
import HooYah.Yacht.common.excetion.ErrorCode;
import HooYah.Yacht.part.domain.Part;
import HooYah.Yacht.part.repository.PartRepository;
import HooYah.Yacht.repair.domain.Repair;
import HooYah.Yacht.repair.repository.RepairPort;
import HooYah.Yacht.repair.repository.RepairRepository;
import HooYah.Yacht.user.domain.User;
import HooYah.Yacht.user.repository.YachtUserPort;
import HooYah.Yacht.yacht.domain.Yacht;
import HooYah.Yacht.yacht.repository.YachtRepository;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class CalendarService {

    private final CalendarRepository calendarRepository;
    private final PartRepository partRepository;
    private final YachtRepository yachtRepository;
    private final RepairPort repairPort;
    private final RepairRepository repairRepository;
    private final YachtUserPort yachtUserPort;

    @Transactional
    public CalendarInfo createCalendar(CalendarCreateRequest request, User user) {
        validateDateRange(request.getStartDate(), request.getEndDate());

        Part part = findPartOrNull(request.getPartId());
        Yacht yacht = findYachtOrNull(request.getYachtId());
        
        if (yacht != null) {
            yachtUserPort.validateYachtUser(yacht, user.getId());
        }
        
        boolean completed = Boolean.TRUE.equals(request.getCompleted());
        boolean byUser = request.getByUser() != null 
                ? Boolean.TRUE.equals(request.getByUser())
                : (request.getType() == CalendarType.SAILING || request.getType() == CalendarType.INSPECTION);
        
        // 같은 부품에 하나의 캘린더만 존재하도록 처리
        if (request.getType() == CalendarType.PART && part != null) {
            List<Calendar> existingPartCalendars = calendarRepository
                    .findByPartAndType(part, CalendarType.PART);
            
            if (!existingPartCalendars.isEmpty()) {
                // 기존 자동 생성 캘린더 찾기
                Optional<Calendar> autoGeneratedCalendar = existingPartCalendars.stream()
                        .filter(c -> !c.isByUser())
                        .findFirst();
                
                if (autoGeneratedCalendar.isPresent()) {
                    Calendar existingAutoCalendar = autoGeneratedCalendar.get();
                    // 사용자가 입력한 날짜가 이전 or 이후 -> 기존 자동 생성 캘린더를 업데이트
                    existingAutoCalendar.updateDates(request.getStartDate(), request.getEndDate());
                    if (request.getContent() != null) {
                        existingAutoCalendar.updateContent(request.getContent());
                    }
                    existingAutoCalendar.markAsUserModified();
                    
                    // 완료 상태로 생성하는 경우 정비 이력 추가
                    if (completed && user != null) {
                        handleCompletedCalendar(existingAutoCalendar, null, part, user);
                    }
                    
                    Yacht existingYacht = existingAutoCalendar.getYacht();
                    List<Part> existingParts = null;
                    if (existingYacht != null) {
                        existingParts = partRepository.findPartListByYacht(existingYacht.getId());
                    }
                    return CalendarInfo.from(existingAutoCalendar, existingYacht, existingParts);
                } else {
                    // 자동 생성 캘린더는 없지만 사용자가 생성한 캘린더가 있으면 기존 일정 삭제
                    existingPartCalendars.forEach(calendarRepository::delete);
                }
            }
        }
        
        Calendar calendar = Calendar.builder()
                .type(request.getType())
                .part(part)
                .yacht(yacht)
                .startDate(request.getStartDate())
                .endDate(request.getEndDate())
                .completed(completed)
                .byUser(byUser)
                .content(request.getContent())
                .build();

        Calendar saved = calendarRepository.save(calendar);
        
        // 완료 상태로 생성하는 경우 정비 이력 추가
        if (completed && user != null) {
            handleCompletedCalendar(saved, request.getPartId(), part, user);
        }
        
        Yacht savedYacht = saved.getYacht();
        List<Part> savedParts = null;
        if (savedYacht != null) {
            savedParts = partRepository.findPartListByYacht(savedYacht.getId());
        }
        return CalendarInfo.from(saved, savedYacht, savedParts);
    }

    public CalendarInfo getCalendar(Long id, User user) {
        Calendar calendar = getCalendarOrThrow(id);
        Yacht yacht = calendar.getYacht();
        
        if (yacht != null) {
            yachtUserPort.validateYachtUser(yacht, user.getId());
        }
        
        List<Part> parts = null;
        if (yacht != null) {
            parts = partRepository.findPartListByYacht(yacht.getId());
        }
        return CalendarInfo.from(calendar, yacht, parts);
    }

    public List<CalendarInfo> getCalendars(Long partId, User user) {
        
        List<Yacht> userYachts = yachtUserPort.findYachtListByUser(user.getId());
        List<Long> yachtIds = userYachts.stream().map(Yacht::getId).toList();
        
        List<Calendar> calendars;
        if (partId != null) {
            calendars = calendarRepository.findAllByPartId(partId).stream()
                    .filter(calendar -> calendar.getYacht() != null 
                            && yachtIds.contains(calendar.getYacht().getId()))
                    .toList();
        } else {
            calendars = calendarRepository.findAll().stream()
                    .filter(calendar -> calendar.getYacht() != null 
                            && yachtIds.contains(calendar.getYacht().getId()))
                    .toList();
        }

        return calendars.stream()
                .map(calendar -> {
                    Yacht yacht = calendar.getYacht();
                    List<Part> parts = null;
                    if (yacht != null) {
                        parts = partRepository.findPartListByYacht(yacht.getId());
                    }
                    return CalendarInfo.from(calendar, yacht, parts);
                })
                .collect(Collectors.toList());
    }

    @Transactional
    public CalendarInfo updateCalendar(Long id, CalendarUpdateRequest request, User user) {
        validateDateRange(request.getStartDate(), request.getEndDate());

        Calendar calendar = getCalendarOrThrow(id);
        
        Yacht existingYacht = calendar.getYacht();
        if (existingYacht != null) {
            yachtUserPort.validateYachtUser(existingYacht, user.getId());
        }
        
        Part part = findPartOrNull(request.getPartId());
        Yacht yacht = findYachtOrNull(request.getYachtId());
        
        if (yacht != null) {
            yachtUserPort.validateYachtUser(yacht, user.getId());
        }
        
        boolean isDateChanged = !calendar.getStartDate().equals(request.getStartDate()) 
                || !calendar.getEndDate().equals(request.getEndDate());

        // 사용자가 수정했는지
        boolean shouldMarkAsUserModified = calendar.getType() == CalendarType.PART 
                && isDateChanged 
                && !calendar.isByUser();
        
        if (shouldMarkAsUserModified) {
            calendar.markAsUserModified();
        }
        
        // 완료 상태가 false에서 true로 변경될 때 처리
        boolean wasCompleted = calendar.isCompleted();
        boolean willBeCompleted = Boolean.TRUE.equals(request.getCompleted());
        boolean isCompleting = !wasCompleted && willBeCompleted;
        
        calendar.update(
                request.getType(),
                part,
                yacht,
                request.getStartDate(),
                request.getEndDate(),
                request.getCompleted(),
                request.getByUser(),
                request.getContent(),
                calendar.getLastRepairDate()
        );

        if (isCompleting && user != null) {
            handleCompletedCalendar(calendar, request.getPartId(), part, user);
        }

        Yacht updatedYacht = calendar.getYacht();
        List<Part> updatedParts = null;
        if (updatedYacht != null) {
            updatedParts = partRepository.findPartListByYacht(updatedYacht.getId());
        }
        return CalendarInfo.from(calendar, updatedYacht, updatedParts);
    }

    @Transactional
    public void deleteCalendar(Long id, User user) {
        Calendar calendar = getCalendarOrThrow(id);
        
        Yacht yacht = calendar.getYacht();
        if (yacht != null) {
            yachtUserPort.validateYachtUser(yacht, user.getId());
        }
        
        calendarRepository.delete(calendar);
    }

    private Calendar getCalendarOrThrow(Long id) {
        return calendarRepository.findById(id)
                .orElseThrow(() -> new CustomException(ErrorCode.NOT_FOUND));
    }

    private Part findPartOrNull(Long partId) {
        if (partId == null) {
            return null;
        }

        return partRepository.findById(partId)
                .orElseThrow(() -> new CustomException(ErrorCode.NOT_FOUND));
    }

    private Yacht findYachtOrNull(Long yachtId) {
        if (yachtId == null) {
            return null;
        }

        return yachtRepository.findById(yachtId)
                .orElseThrow(() -> new CustomException(ErrorCode.NOT_FOUND));
    }

    @Transactional
    public void updatePartTypeCalendar(Part part) {
        updatePartTypeCalendar(part, null);
    }

    @Transactional
    public void updatePartTypeCalendar(Part part, OffsetDateTime repairDate) {
        // 정비 주기가 없으면 캘린더 자동 생성 X
        if (part.getInterval() == null) {
            return;
        }

        // repairDate가 제공되면 사용, 없으면 최근 정비일 조회
        OffsetDateTime lastRepairDate;
        if (repairDate != null) {
            lastRepairDate = repairDate;
        } else {
            Optional<Repair> lastRepairOpt = repairPort.findLastRepair(part);
            if (lastRepairOpt.isEmpty()) {
                return; // 정비 이력이 없으면 캘린더 자동 생성 X
            }
            lastRepairDate = lastRepairOpt.get().getRepairDate();
        }

        OffsetDateTime nextRepairDate = part.nextRepairDate(lastRepairDate);
        OffsetDateTime now = OffsetDateTime.now();

        // next repair date가 오늘 이전이라면 interval을 더해서 미래 날짜가 될 때까지 반복 계산
        while (nextRepairDate.isBefore(now)) {
            nextRepairDate = part.nextRepairDate(nextRepairDate);
        }

        // 기존 자동 생성된 부품 캘린더 조회 (사용자가 수정하지 않은 것만) -> 자동 생성된 캘린더는 byUser가 false
        Optional<Calendar> existingCalendarOpt = calendarRepository
                .findByPartAndTypeAndByUserFalse(part, CalendarType.PART);

        if (existingCalendarOpt.isPresent()) {
            // 기존 캘린더가 있으면 최신 정비일로 업데이트 (정비 이력이 변경되었을 수 있으므로)
            Calendar existingCalendar = existingCalendarOpt.get();
            existingCalendar.updateLastRepairDate(lastRepairDate);
            
            // 예상 정비일은 미래일 때만 업데이트 (과거 일정은 업데이트하지 않음)
            if (nextRepairDate.isAfter(now) || nextRepairDate.isEqual(now)) {
                existingCalendar.updateDates(nextRepairDate, nextRepairDate);
            }
        } else {
            // 기존 캘린더가 없으면 새로 생성
            Calendar newCalendar = Calendar.builder()
                    .type(CalendarType.PART)
                    .part(part)
                    .yacht(part.getYacht())
                    .startDate(nextRepairDate)
                    .endDate(nextRepairDate)
                    .completed(false)
                    .byUser(false)
                    .content(null)
                    .lastRepairDate(lastRepairDate)
                    .build();
            calendarRepository.save(newCalendar);
        }
    }


    private void validateDateRange(OffsetDateTime startDate, OffsetDateTime endDate) {
        if (startDate != null && endDate != null && endDate.isBefore(startDate)) {
            throw new CustomException(ErrorCode.BAD_REQUEST);
        }
    }

    private void handleCompletedCalendar(Calendar calendar, Long requestPartId, Part part, User user) {
        CalendarType calendarType = calendar.getType();
        Part calendarPart = calendar.getPart();
        
        if (calendarType == CalendarType.PART && calendarPart != null) {
            // 부품 타입: 정비 이력 추가 및 다음 일정 자동 생성
            addRepairAndCreateNextCalendar(calendarPart, user);
        } else if ((calendarType == CalendarType.SAILING || calendarType == CalendarType.INSPECTION)
                && requestPartId != null && part != null
                && part.getYacht().equals(calendar.getYacht())) {
            // 세일링/점검 타입: 부품 id가 요트에 등록된 부품 id라면 정비 이력 추가
            addRepair(part, user);
        }
    }

    private void addRepairAndCreateNextCalendar(Part part, User user) {
        OffsetDateTime repairDate = addRepair(part, user);
        updatePartTypeCalendar(part, repairDate);
    }

    private OffsetDateTime addRepair(Part part, User user) {
        OffsetDateTime repairDate = OffsetDateTime.now();
        Repair repair = Repair.builder()
                .part(part)
                .user(user)
                .repairDate(repairDate)
                .build();
        repairRepository.save(repair);
        return repairDate;
    }
}

